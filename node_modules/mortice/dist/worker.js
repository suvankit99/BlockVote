"use strict";
(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));

  // node_modules/eventemitter3/index.js
  var require_eventemitter3 = __commonJS({
    "node_modules/eventemitter3/index.js"(exports, module) {
      "use strict";
      var has = Object.prototype.hasOwnProperty;
      var prefix = "~";
      function Events() {
      }
      if (Object.create) {
        Events.prototype = /* @__PURE__ */ Object.create(null);
        if (!new Events().__proto__)
          prefix = false;
      }
      function EE(fn, context, once) {
        this.fn = fn;
        this.context = context;
        this.once = once || false;
      }
      function addListener(emitter, event, fn, context, once) {
        if (typeof fn !== "function") {
          throw new TypeError("The listener must be a function");
        }
        var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;
        if (!emitter._events[evt])
          emitter._events[evt] = listener, emitter._eventsCount++;
        else if (!emitter._events[evt].fn)
          emitter._events[evt].push(listener);
        else
          emitter._events[evt] = [emitter._events[evt], listener];
        return emitter;
      }
      function clearEvent(emitter, evt) {
        if (--emitter._eventsCount === 0)
          emitter._events = new Events();
        else
          delete emitter._events[evt];
      }
      function EventEmitter2() {
        this._events = new Events();
        this._eventsCount = 0;
      }
      EventEmitter2.prototype.eventNames = function eventNames() {
        var names = [], events2, name;
        if (this._eventsCount === 0)
          return names;
        for (name in events2 = this._events) {
          if (has.call(events2, name))
            names.push(prefix ? name.slice(1) : name);
        }
        if (Object.getOwnPropertySymbols) {
          return names.concat(Object.getOwnPropertySymbols(events2));
        }
        return names;
      };
      EventEmitter2.prototype.listeners = function listeners(event) {
        var evt = prefix ? prefix + event : event, handlers = this._events[evt];
        if (!handlers)
          return [];
        if (handlers.fn)
          return [handlers.fn];
        for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
          ee[i] = handlers[i].fn;
        }
        return ee;
      };
      EventEmitter2.prototype.listenerCount = function listenerCount(event) {
        var evt = prefix ? prefix + event : event, listeners = this._events[evt];
        if (!listeners)
          return 0;
        if (listeners.fn)
          return 1;
        return listeners.length;
      };
      EventEmitter2.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
        var evt = prefix ? prefix + event : event;
        if (!this._events[evt])
          return false;
        var listeners = this._events[evt], len = arguments.length, args, i;
        if (listeners.fn) {
          if (listeners.once)
            this.removeListener(event, listeners.fn, void 0, true);
          switch (len) {
            case 1:
              return listeners.fn.call(listeners.context), true;
            case 2:
              return listeners.fn.call(listeners.context, a1), true;
            case 3:
              return listeners.fn.call(listeners.context, a1, a2), true;
            case 4:
              return listeners.fn.call(listeners.context, a1, a2, a3), true;
            case 5:
              return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
            case 6:
              return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
          }
          for (i = 1, args = new Array(len - 1); i < len; i++) {
            args[i - 1] = arguments[i];
          }
          listeners.fn.apply(listeners.context, args);
        } else {
          var length = listeners.length, j;
          for (i = 0; i < length; i++) {
            if (listeners[i].once)
              this.removeListener(event, listeners[i].fn, void 0, true);
            switch (len) {
              case 1:
                listeners[i].fn.call(listeners[i].context);
                break;
              case 2:
                listeners[i].fn.call(listeners[i].context, a1);
                break;
              case 3:
                listeners[i].fn.call(listeners[i].context, a1, a2);
                break;
              case 4:
                listeners[i].fn.call(listeners[i].context, a1, a2, a3);
                break;
              default:
                if (!args)
                  for (j = 1, args = new Array(len - 1); j < len; j++) {
                    args[j - 1] = arguments[j];
                  }
                listeners[i].fn.apply(listeners[i].context, args);
            }
          }
        }
        return true;
      };
      EventEmitter2.prototype.on = function on(event, fn, context) {
        return addListener(this, event, fn, context, false);
      };
      EventEmitter2.prototype.once = function once(event, fn, context) {
        return addListener(this, event, fn, context, true);
      };
      EventEmitter2.prototype.removeListener = function removeListener(event, fn, context, once) {
        var evt = prefix ? prefix + event : event;
        if (!this._events[evt])
          return this;
        if (!fn) {
          clearEvent(this, evt);
          return this;
        }
        var listeners = this._events[evt];
        if (listeners.fn) {
          if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
            clearEvent(this, evt);
          }
        } else {
          for (var i = 0, events2 = [], length = listeners.length; i < length; i++) {
            if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {
              events2.push(listeners[i]);
            }
          }
          if (events2.length)
            this._events[evt] = events2.length === 1 ? events2[0] : events2;
          else
            clearEvent(this, evt);
        }
        return this;
      };
      EventEmitter2.prototype.removeAllListeners = function removeAllListeners(event) {
        var evt;
        if (event) {
          evt = prefix ? prefix + event : event;
          if (this._events[evt])
            clearEvent(this, evt);
        } else {
          this._events = new Events();
          this._eventsCount = 0;
        }
        return this;
      };
      EventEmitter2.prototype.off = EventEmitter2.prototype.removeListener;
      EventEmitter2.prototype.addListener = EventEmitter2.prototype.on;
      EventEmitter2.prefixed = prefix;
      EventEmitter2.EventEmitter = EventEmitter2;
      if ("undefined" !== typeof module) {
        module.exports = EventEmitter2;
      }
    }
  });

  // node_modules/eventemitter3/index.mjs
  var import_index = __toESM(require_eventemitter3(), 1);

  // node_modules/p-queue/node_modules/p-timeout/index.js
  var TimeoutError = class extends Error {
    constructor(message) {
      super(message);
      this.name = "TimeoutError";
    }
  };
  var AbortError = class extends Error {
    constructor(message) {
      super();
      this.name = "AbortError";
      this.message = message;
    }
  };
  var getDOMException = (errorMessage) => globalThis.DOMException === void 0 ? new AbortError(errorMessage) : new DOMException(errorMessage);
  var getAbortedReason = (signal) => {
    const reason = signal.reason === void 0 ? getDOMException("This operation was aborted.") : signal.reason;
    return reason instanceof Error ? reason : getDOMException(reason);
  };
  function pTimeout(promise, milliseconds, fallback, options) {
    let timer;
    const cancelablePromise = new Promise((resolve, reject) => {
      if (typeof milliseconds !== "number" || Math.sign(milliseconds) !== 1) {
        throw new TypeError(`Expected \`milliseconds\` to be a positive number, got \`${milliseconds}\``);
      }
      if (milliseconds === Number.POSITIVE_INFINITY) {
        resolve(promise);
        return;
      }
      options = {
        customTimers: { setTimeout, clearTimeout },
        ...options
      };
      if (options.signal) {
        const { signal } = options;
        if (signal.aborted) {
          reject(getAbortedReason(signal));
        }
        signal.addEventListener("abort", () => {
          reject(getAbortedReason(signal));
        });
      }
      timer = options.customTimers.setTimeout.call(void 0, () => {
        if (typeof fallback === "function") {
          try {
            resolve(fallback());
          } catch (error) {
            reject(error);
          }
          return;
        }
        const message = typeof fallback === "string" ? fallback : `Promise timed out after ${milliseconds} milliseconds`;
        const timeoutError = fallback instanceof Error ? fallback : new TimeoutError(message);
        if (typeof promise.cancel === "function") {
          promise.cancel();
        }
        reject(timeoutError);
      }, milliseconds);
      (async () => {
        try {
          resolve(await promise);
        } catch (error) {
          reject(error);
        } finally {
          options.customTimers.clearTimeout.call(void 0, timer);
        }
      })();
    });
    cancelablePromise.clear = () => {
      clearTimeout(timer);
      timer = void 0;
    };
    return cancelablePromise;
  }

  // node_modules/p-queue/dist/lower-bound.js
  function lowerBound(array, value, comparator) {
    let first = 0;
    let count = array.length;
    while (count > 0) {
      const step = Math.trunc(count / 2);
      let it = first + step;
      if (comparator(array[it], value) <= 0) {
        first = ++it;
        count -= step + 1;
      } else {
        count = step;
      }
    }
    return first;
  }

  // node_modules/p-queue/dist/priority-queue.js
  var __classPrivateFieldGet = function(receiver, state, kind, f) {
    if (kind === "a" && !f)
      throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
      throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
  };
  var _PriorityQueue_queue;
  var PriorityQueue = class {
    constructor() {
      _PriorityQueue_queue.set(this, []);
    }
    enqueue(run2, options) {
      options = {
        priority: 0,
        ...options
      };
      const element = {
        priority: options.priority,
        run: run2
      };
      if (this.size && __classPrivateFieldGet(this, _PriorityQueue_queue, "f")[this.size - 1].priority >= options.priority) {
        __classPrivateFieldGet(this, _PriorityQueue_queue, "f").push(element);
        return;
      }
      const index = lowerBound(__classPrivateFieldGet(this, _PriorityQueue_queue, "f"), element, (a, b) => b.priority - a.priority);
      __classPrivateFieldGet(this, _PriorityQueue_queue, "f").splice(index, 0, element);
    }
    dequeue() {
      const item = __classPrivateFieldGet(this, _PriorityQueue_queue, "f").shift();
      return item === null || item === void 0 ? void 0 : item.run;
    }
    filter(options) {
      return __classPrivateFieldGet(this, _PriorityQueue_queue, "f").filter((element) => element.priority === options.priority).map((element) => element.run);
    }
    get size() {
      return __classPrivateFieldGet(this, _PriorityQueue_queue, "f").length;
    }
  };
  _PriorityQueue_queue = /* @__PURE__ */ new WeakMap();
  var priority_queue_default = PriorityQueue;

  // node_modules/p-queue/dist/index.js
  var __classPrivateFieldSet = function(receiver, state, value, kind, f) {
    if (kind === "m")
      throw new TypeError("Private method is not writable");
    if (kind === "a" && !f)
      throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
      throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
  };
  var __classPrivateFieldGet2 = function(receiver, state, kind, f) {
    if (kind === "a" && !f)
      throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
      throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
  };
  var _PQueue_instances;
  var _PQueue_carryoverConcurrencyCount;
  var _PQueue_isIntervalIgnored;
  var _PQueue_intervalCount;
  var _PQueue_intervalCap;
  var _PQueue_interval;
  var _PQueue_intervalEnd;
  var _PQueue_intervalId;
  var _PQueue_timeoutId;
  var _PQueue_queue;
  var _PQueue_queueClass;
  var _PQueue_pending;
  var _PQueue_concurrency;
  var _PQueue_isPaused;
  var _PQueue_throwOnTimeout;
  var _PQueue_doesIntervalAllowAnother_get;
  var _PQueue_doesConcurrentAllowAnother_get;
  var _PQueue_next;
  var _PQueue_onResumeInterval;
  var _PQueue_isIntervalPaused_get;
  var _PQueue_tryToStartAnother;
  var _PQueue_initializeIntervalIfNeeded;
  var _PQueue_onInterval;
  var _PQueue_processQueue;
  var _PQueue_throwOnAbort;
  var _PQueue_onEvent;
  var AbortError2 = class extends Error {
  };
  var PQueue = class extends import_index.default {
    // TODO: The `throwOnTimeout` option should affect the return types of `add()` and `addAll()`
    constructor(options) {
      var _a, _b, _c, _d;
      super();
      _PQueue_instances.add(this);
      _PQueue_carryoverConcurrencyCount.set(this, void 0);
      _PQueue_isIntervalIgnored.set(this, void 0);
      _PQueue_intervalCount.set(this, 0);
      _PQueue_intervalCap.set(this, void 0);
      _PQueue_interval.set(this, void 0);
      _PQueue_intervalEnd.set(this, 0);
      _PQueue_intervalId.set(this, void 0);
      _PQueue_timeoutId.set(this, void 0);
      _PQueue_queue.set(this, void 0);
      _PQueue_queueClass.set(this, void 0);
      _PQueue_pending.set(this, 0);
      _PQueue_concurrency.set(this, void 0);
      _PQueue_isPaused.set(this, void 0);
      _PQueue_throwOnTimeout.set(this, void 0);
      Object.defineProperty(this, "timeout", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      options = {
        carryoverConcurrencyCount: false,
        intervalCap: Number.POSITIVE_INFINITY,
        interval: 0,
        concurrency: Number.POSITIVE_INFINITY,
        autoStart: true,
        queueClass: priority_queue_default,
        ...options
      };
      if (!(typeof options.intervalCap === "number" && options.intervalCap >= 1)) {
        throw new TypeError(`Expected \`intervalCap\` to be a number from 1 and up, got \`${(_b = (_a = options.intervalCap) === null || _a === void 0 ? void 0 : _a.toString()) !== null && _b !== void 0 ? _b : ""}\` (${typeof options.intervalCap})`);
      }
      if (options.interval === void 0 || !(Number.isFinite(options.interval) && options.interval >= 0)) {
        throw new TypeError(`Expected \`interval\` to be a finite number >= 0, got \`${(_d = (_c = options.interval) === null || _c === void 0 ? void 0 : _c.toString()) !== null && _d !== void 0 ? _d : ""}\` (${typeof options.interval})`);
      }
      __classPrivateFieldSet(this, _PQueue_carryoverConcurrencyCount, options.carryoverConcurrencyCount, "f");
      __classPrivateFieldSet(this, _PQueue_isIntervalIgnored, options.intervalCap === Number.POSITIVE_INFINITY || options.interval === 0, "f");
      __classPrivateFieldSet(this, _PQueue_intervalCap, options.intervalCap, "f");
      __classPrivateFieldSet(this, _PQueue_interval, options.interval, "f");
      __classPrivateFieldSet(this, _PQueue_queue, new options.queueClass(), "f");
      __classPrivateFieldSet(this, _PQueue_queueClass, options.queueClass, "f");
      this.concurrency = options.concurrency;
      this.timeout = options.timeout;
      __classPrivateFieldSet(this, _PQueue_throwOnTimeout, options.throwOnTimeout === true, "f");
      __classPrivateFieldSet(this, _PQueue_isPaused, options.autoStart === false, "f");
    }
    get concurrency() {
      return __classPrivateFieldGet2(this, _PQueue_concurrency, "f");
    }
    set concurrency(newConcurrency) {
      if (!(typeof newConcurrency === "number" && newConcurrency >= 1)) {
        throw new TypeError(`Expected \`concurrency\` to be a number from 1 and up, got \`${newConcurrency}\` (${typeof newConcurrency})`);
      }
      __classPrivateFieldSet(this, _PQueue_concurrency, newConcurrency, "f");
      __classPrivateFieldGet2(this, _PQueue_instances, "m", _PQueue_processQueue).call(this);
    }
    async add(function_, options = {}) {
      options = {
        timeout: this.timeout,
        throwOnTimeout: __classPrivateFieldGet2(this, _PQueue_throwOnTimeout, "f"),
        ...options
      };
      return new Promise((resolve, reject) => {
        __classPrivateFieldGet2(this, _PQueue_queue, "f").enqueue(async () => {
          var _a;
          var _b, _c;
          __classPrivateFieldSet(this, _PQueue_pending, (_b = __classPrivateFieldGet2(this, _PQueue_pending, "f"), _b++, _b), "f");
          __classPrivateFieldSet(this, _PQueue_intervalCount, (_c = __classPrivateFieldGet2(this, _PQueue_intervalCount, "f"), _c++, _c), "f");
          try {
            if ((_a = options.signal) === null || _a === void 0 ? void 0 : _a.aborted) {
              throw new AbortError2("The task was aborted.");
            }
            let operation = function_({ signal: options.signal });
            if (options.timeout) {
              operation = pTimeout(Promise.resolve(operation), options.timeout);
            }
            if (options.signal) {
              operation = Promise.race([operation, __classPrivateFieldGet2(this, _PQueue_instances, "m", _PQueue_throwOnAbort).call(this, options.signal)]);
            }
            const result = await operation;
            resolve(result);
            this.emit("completed", result);
          } catch (error) {
            if (error instanceof TimeoutError && !options.throwOnTimeout) {
              resolve();
              return;
            }
            reject(error);
            this.emit("error", error);
          } finally {
            __classPrivateFieldGet2(this, _PQueue_instances, "m", _PQueue_next).call(this);
          }
        }, options);
        this.emit("add");
        __classPrivateFieldGet2(this, _PQueue_instances, "m", _PQueue_tryToStartAnother).call(this);
      });
    }
    async addAll(functions, options) {
      return Promise.all(functions.map(async (function_) => this.add(function_, options)));
    }
    /**
    Start (or resume) executing enqueued tasks within concurrency limit. No need to call this if queue is not paused (via `options.autoStart = false` or by `.pause()` method.)
    */
    start() {
      if (!__classPrivateFieldGet2(this, _PQueue_isPaused, "f")) {
        return this;
      }
      __classPrivateFieldSet(this, _PQueue_isPaused, false, "f");
      __classPrivateFieldGet2(this, _PQueue_instances, "m", _PQueue_processQueue).call(this);
      return this;
    }
    /**
    Put queue execution on hold.
    */
    pause() {
      __classPrivateFieldSet(this, _PQueue_isPaused, true, "f");
    }
    /**
    Clear the queue.
    */
    clear() {
      __classPrivateFieldSet(this, _PQueue_queue, new (__classPrivateFieldGet2(this, _PQueue_queueClass, "f"))(), "f");
    }
    /**
        Can be called multiple times. Useful if you for example add additional items at a later time.
    
        @returns A promise that settles when the queue becomes empty.
        */
    async onEmpty() {
      if (__classPrivateFieldGet2(this, _PQueue_queue, "f").size === 0) {
        return;
      }
      await __classPrivateFieldGet2(this, _PQueue_instances, "m", _PQueue_onEvent).call(this, "empty");
    }
    /**
        @returns A promise that settles when the queue size is less than the given limit: `queue.size < limit`.
    
        If you want to avoid having the queue grow beyond a certain size you can `await queue.onSizeLessThan()` before adding a new item.
    
        Note that this only limits the number of items waiting to start. There could still be up to `concurrency` jobs already running that this call does not include in its calculation.
        */
    async onSizeLessThan(limit) {
      if (__classPrivateFieldGet2(this, _PQueue_queue, "f").size < limit) {
        return;
      }
      await __classPrivateFieldGet2(this, _PQueue_instances, "m", _PQueue_onEvent).call(this, "next", () => __classPrivateFieldGet2(this, _PQueue_queue, "f").size < limit);
    }
    /**
        The difference with `.onEmpty` is that `.onIdle` guarantees that all work from the queue has finished. `.onEmpty` merely signals that the queue is empty, but it could mean that some promises haven't completed yet.
    
        @returns A promise that settles when the queue becomes empty, and all promises have completed; `queue.size === 0 && queue.pending === 0`.
        */
    async onIdle() {
      if (__classPrivateFieldGet2(this, _PQueue_pending, "f") === 0 && __classPrivateFieldGet2(this, _PQueue_queue, "f").size === 0) {
        return;
      }
      await __classPrivateFieldGet2(this, _PQueue_instances, "m", _PQueue_onEvent).call(this, "idle");
    }
    /**
    Size of the queue, the number of queued items waiting to run.
    */
    get size() {
      return __classPrivateFieldGet2(this, _PQueue_queue, "f").size;
    }
    /**
        Size of the queue, filtered by the given options.
    
        For example, this can be used to find the number of items remaining in the queue with a specific priority level.
        */
    sizeBy(options) {
      return __classPrivateFieldGet2(this, _PQueue_queue, "f").filter(options).length;
    }
    /**
    Number of running items (no longer in the queue).
    */
    get pending() {
      return __classPrivateFieldGet2(this, _PQueue_pending, "f");
    }
    /**
    Whether the queue is currently paused.
    */
    get isPaused() {
      return __classPrivateFieldGet2(this, _PQueue_isPaused, "f");
    }
  };
  _PQueue_carryoverConcurrencyCount = /* @__PURE__ */ new WeakMap(), _PQueue_isIntervalIgnored = /* @__PURE__ */ new WeakMap(), _PQueue_intervalCount = /* @__PURE__ */ new WeakMap(), _PQueue_intervalCap = /* @__PURE__ */ new WeakMap(), _PQueue_interval = /* @__PURE__ */ new WeakMap(), _PQueue_intervalEnd = /* @__PURE__ */ new WeakMap(), _PQueue_intervalId = /* @__PURE__ */ new WeakMap(), _PQueue_timeoutId = /* @__PURE__ */ new WeakMap(), _PQueue_queue = /* @__PURE__ */ new WeakMap(), _PQueue_queueClass = /* @__PURE__ */ new WeakMap(), _PQueue_pending = /* @__PURE__ */ new WeakMap(), _PQueue_concurrency = /* @__PURE__ */ new WeakMap(), _PQueue_isPaused = /* @__PURE__ */ new WeakMap(), _PQueue_throwOnTimeout = /* @__PURE__ */ new WeakMap(), _PQueue_instances = /* @__PURE__ */ new WeakSet(), _PQueue_doesIntervalAllowAnother_get = function _PQueue_doesIntervalAllowAnother_get2() {
    return __classPrivateFieldGet2(this, _PQueue_isIntervalIgnored, "f") || __classPrivateFieldGet2(this, _PQueue_intervalCount, "f") < __classPrivateFieldGet2(this, _PQueue_intervalCap, "f");
  }, _PQueue_doesConcurrentAllowAnother_get = function _PQueue_doesConcurrentAllowAnother_get2() {
    return __classPrivateFieldGet2(this, _PQueue_pending, "f") < __classPrivateFieldGet2(this, _PQueue_concurrency, "f");
  }, _PQueue_next = function _PQueue_next2() {
    var _a;
    __classPrivateFieldSet(this, _PQueue_pending, (_a = __classPrivateFieldGet2(this, _PQueue_pending, "f"), _a--, _a), "f");
    __classPrivateFieldGet2(this, _PQueue_instances, "m", _PQueue_tryToStartAnother).call(this);
    this.emit("next");
  }, _PQueue_onResumeInterval = function _PQueue_onResumeInterval2() {
    __classPrivateFieldGet2(this, _PQueue_instances, "m", _PQueue_onInterval).call(this);
    __classPrivateFieldGet2(this, _PQueue_instances, "m", _PQueue_initializeIntervalIfNeeded).call(this);
    __classPrivateFieldSet(this, _PQueue_timeoutId, void 0, "f");
  }, _PQueue_isIntervalPaused_get = function _PQueue_isIntervalPaused_get2() {
    const now = Date.now();
    if (__classPrivateFieldGet2(this, _PQueue_intervalId, "f") === void 0) {
      const delay2 = __classPrivateFieldGet2(this, _PQueue_intervalEnd, "f") - now;
      if (delay2 < 0) {
        __classPrivateFieldSet(this, _PQueue_intervalCount, __classPrivateFieldGet2(this, _PQueue_carryoverConcurrencyCount, "f") ? __classPrivateFieldGet2(this, _PQueue_pending, "f") : 0, "f");
      } else {
        if (__classPrivateFieldGet2(this, _PQueue_timeoutId, "f") === void 0) {
          __classPrivateFieldSet(this, _PQueue_timeoutId, setTimeout(() => {
            __classPrivateFieldGet2(this, _PQueue_instances, "m", _PQueue_onResumeInterval).call(this);
          }, delay2), "f");
        }
        return true;
      }
    }
    return false;
  }, _PQueue_tryToStartAnother = function _PQueue_tryToStartAnother2() {
    if (__classPrivateFieldGet2(this, _PQueue_queue, "f").size === 0) {
      if (__classPrivateFieldGet2(this, _PQueue_intervalId, "f")) {
        clearInterval(__classPrivateFieldGet2(this, _PQueue_intervalId, "f"));
      }
      __classPrivateFieldSet(this, _PQueue_intervalId, void 0, "f");
      this.emit("empty");
      if (__classPrivateFieldGet2(this, _PQueue_pending, "f") === 0) {
        this.emit("idle");
      }
      return false;
    }
    if (!__classPrivateFieldGet2(this, _PQueue_isPaused, "f")) {
      const canInitializeInterval = !__classPrivateFieldGet2(this, _PQueue_instances, "a", _PQueue_isIntervalPaused_get);
      if (__classPrivateFieldGet2(this, _PQueue_instances, "a", _PQueue_doesIntervalAllowAnother_get) && __classPrivateFieldGet2(this, _PQueue_instances, "a", _PQueue_doesConcurrentAllowAnother_get)) {
        const job = __classPrivateFieldGet2(this, _PQueue_queue, "f").dequeue();
        if (!job) {
          return false;
        }
        this.emit("active");
        job();
        if (canInitializeInterval) {
          __classPrivateFieldGet2(this, _PQueue_instances, "m", _PQueue_initializeIntervalIfNeeded).call(this);
        }
        return true;
      }
    }
    return false;
  }, _PQueue_initializeIntervalIfNeeded = function _PQueue_initializeIntervalIfNeeded2() {
    if (__classPrivateFieldGet2(this, _PQueue_isIntervalIgnored, "f") || __classPrivateFieldGet2(this, _PQueue_intervalId, "f") !== void 0) {
      return;
    }
    __classPrivateFieldSet(this, _PQueue_intervalId, setInterval(() => {
      __classPrivateFieldGet2(this, _PQueue_instances, "m", _PQueue_onInterval).call(this);
    }, __classPrivateFieldGet2(this, _PQueue_interval, "f")), "f");
    __classPrivateFieldSet(this, _PQueue_intervalEnd, Date.now() + __classPrivateFieldGet2(this, _PQueue_interval, "f"), "f");
  }, _PQueue_onInterval = function _PQueue_onInterval2() {
    if (__classPrivateFieldGet2(this, _PQueue_intervalCount, "f") === 0 && __classPrivateFieldGet2(this, _PQueue_pending, "f") === 0 && __classPrivateFieldGet2(this, _PQueue_intervalId, "f")) {
      clearInterval(__classPrivateFieldGet2(this, _PQueue_intervalId, "f"));
      __classPrivateFieldSet(this, _PQueue_intervalId, void 0, "f");
    }
    __classPrivateFieldSet(this, _PQueue_intervalCount, __classPrivateFieldGet2(this, _PQueue_carryoverConcurrencyCount, "f") ? __classPrivateFieldGet2(this, _PQueue_pending, "f") : 0, "f");
    __classPrivateFieldGet2(this, _PQueue_instances, "m", _PQueue_processQueue).call(this);
  }, _PQueue_processQueue = function _PQueue_processQueue2() {
    while (__classPrivateFieldGet2(this, _PQueue_instances, "m", _PQueue_tryToStartAnother).call(this)) {
    }
  }, _PQueue_throwOnAbort = async function _PQueue_throwOnAbort2(signal) {
    return new Promise((_resolve, reject) => {
      signal.addEventListener("abort", () => {
        reject(new AbortError2("The task was aborted."));
      }, { once: true });
    });
  }, _PQueue_onEvent = async function _PQueue_onEvent2(event, filter) {
    return new Promise((resolve) => {
      const listener = () => {
        if (filter && !filter()) {
          return;
        }
        this.off(event, listener);
        resolve();
      };
      this.on(event, listener);
    });
  };
  var dist_default = PQueue;

  // node_modules/p-timeout/index.js
  var TimeoutError2 = class extends Error {
    constructor(message) {
      super(message);
      this.name = "TimeoutError";
    }
  };
  var AbortError3 = class extends Error {
    constructor(message) {
      super();
      this.name = "AbortError";
      this.message = message;
    }
  };
  var getDOMException2 = (errorMessage) => globalThis.DOMException === void 0 ? new AbortError3(errorMessage) : new DOMException(errorMessage);
  var getAbortedReason2 = (signal) => {
    const reason = signal.reason === void 0 ? getDOMException2("This operation was aborted.") : signal.reason;
    return reason instanceof Error ? reason : getDOMException2(reason);
  };
  function pTimeout2(promise, options) {
    const {
      milliseconds,
      fallback,
      message,
      customTimers = { setTimeout, clearTimeout }
    } = options;
    let timer;
    const wrappedPromise = new Promise((resolve, reject) => {
      if (typeof milliseconds !== "number" || Math.sign(milliseconds) !== 1) {
        throw new TypeError(`Expected \`milliseconds\` to be a positive number, got \`${milliseconds}\``);
      }
      if (options.signal) {
        const { signal } = options;
        if (signal.aborted) {
          reject(getAbortedReason2(signal));
        }
        signal.addEventListener("abort", () => {
          reject(getAbortedReason2(signal));
        });
      }
      if (milliseconds === Number.POSITIVE_INFINITY) {
        promise.then(resolve, reject);
        return;
      }
      const timeoutError = new TimeoutError2();
      timer = customTimers.setTimeout.call(void 0, () => {
        if (fallback) {
          try {
            resolve(fallback());
          } catch (error) {
            reject(error);
          }
          return;
        }
        if (typeof promise.cancel === "function") {
          promise.cancel();
        }
        if (message === false) {
          resolve();
        } else if (message instanceof Error) {
          reject(message);
        } else {
          timeoutError.message = message ?? `Promise timed out after ${milliseconds} milliseconds`;
          reject(timeoutError);
        }
      }, milliseconds);
      (async () => {
        try {
          resolve(await promise);
        } catch (error) {
          reject(error);
        }
      })();
    });
    const cancelablePromise = wrappedPromise.finally(() => {
      cancelablePromise.clear();
    });
    cancelablePromise.clear = () => {
      customTimers.clearTimeout.call(void 0, timer);
      timer = void 0;
    };
    return cancelablePromise;
  }

  // node_modules/observable-webworkers/dist/src/index.js
  var events = {};
  var observable = (worker) => {
    worker.addEventListener("message", (event) => {
      observable.dispatchEvent("message", worker, event);
    });
    if (worker.port != null) {
      worker.port.addEventListener("message", (event) => {
        observable.dispatchEvent("message", worker, event);
      });
    }
  };
  observable.addEventListener = (type, fn) => {
    if (events[type] == null) {
      events[type] = [];
    }
    events[type].push(fn);
  };
  observable.removeEventListener = (type, fn) => {
    if (events[type] == null) {
      return;
    }
    events[type] = events[type].filter((listener) => listener === fn);
  };
  observable.dispatchEvent = function(type, worker, event) {
    if (events[type] == null) {
      return;
    }
    events[type].forEach((fn) => fn(worker, event));
  };
  var src_default = observable;

  // src/constants.ts
  var WORKER_REQUEST_READ_LOCK = "lock:worker:request-read";
  var WORKER_RELEASE_READ_LOCK = "lock:worker:release-read";
  var MASTER_GRANT_READ_LOCK = "lock:master:grant-read";
  var WORKER_REQUEST_WRITE_LOCK = "lock:worker:request-write";
  var WORKER_RELEASE_WRITE_LOCK = "lock:worker:release-write";
  var MASTER_GRANT_WRITE_LOCK = "lock:master:grant-write";

  // src/utils.ts
  var nanoid = (size = 21) => {
    return Math.random().toString().substring(2);
  };

  // src/browser.ts
  var handleWorkerLockRequest = (emitter, masterEvent, requestType, releaseType, grantType) => {
    return (worker, event) => {
      if (event.data.type !== requestType) {
        return;
      }
      const requestEvent = {
        type: event.data.type,
        name: event.data.name,
        identifier: event.data.identifier
      };
      emitter.dispatchEvent(new MessageEvent(masterEvent, {
        data: {
          name: requestEvent.name,
          handler: async () => {
            worker.postMessage({
              type: grantType,
              name: requestEvent.name,
              identifier: requestEvent.identifier
            });
            await new Promise((resolve) => {
              const releaseEventListener = (event2) => {
                if (event2 == null || event2.data == null) {
                  return;
                }
                const releaseEvent = {
                  type: event2.data.type,
                  name: event2.data.name,
                  identifier: event2.data.identifier
                };
                if (releaseEvent.type === releaseType && releaseEvent.identifier === requestEvent.identifier) {
                  worker.removeEventListener("message", releaseEventListener);
                  resolve();
                }
              };
              worker.addEventListener("message", releaseEventListener);
            });
          }
        }
      }));
    };
  };
  var makeWorkerLockRequest = (name, requestType, grantType, releaseType) => {
    return async () => {
      const id = nanoid();
      globalThis.postMessage({
        type: requestType,
        identifier: id,
        name
      });
      return new Promise((resolve) => {
        const listener = (event) => {
          if (event == null || event.data == null) {
            return;
          }
          const responseEvent = {
            type: event.data.type,
            identifier: event.data.identifier
          };
          if (responseEvent.type === grantType && responseEvent.identifier === id) {
            globalThis.removeEventListener("message", listener);
            resolve(() => {
              globalThis.postMessage({
                type: releaseType,
                identifier: id,
                name
              });
            });
          }
        };
        globalThis.addEventListener("message", listener);
      });
    };
  };
  var defaultOptions = {
    singleProcess: false
  };
  var browser_default = (options) => {
    options = Object.assign({}, defaultOptions, options);
    const isPrimary = Boolean(globalThis.document) || options.singleProcess;
    if (isPrimary) {
      const emitter = new EventTarget();
      src_default.addEventListener("message", handleWorkerLockRequest(emitter, "requestReadLock", WORKER_REQUEST_READ_LOCK, WORKER_RELEASE_READ_LOCK, MASTER_GRANT_READ_LOCK));
      src_default.addEventListener("message", handleWorkerLockRequest(emitter, "requestWriteLock", WORKER_REQUEST_WRITE_LOCK, WORKER_RELEASE_WRITE_LOCK, MASTER_GRANT_WRITE_LOCK));
      return emitter;
    }
    return {
      isWorker: true,
      readLock: (name) => makeWorkerLockRequest(name, WORKER_REQUEST_READ_LOCK, MASTER_GRANT_READ_LOCK, WORKER_RELEASE_READ_LOCK),
      writeLock: (name) => makeWorkerLockRequest(name, WORKER_REQUEST_WRITE_LOCK, MASTER_GRANT_WRITE_LOCK, WORKER_RELEASE_WRITE_LOCK)
    };
  };

  // src/index.ts
  var mutexes = {};
  var implementation;
  async function createReleaseable(queue, options) {
    let res;
    const p = new Promise((resolve) => {
      res = resolve;
    });
    void queue.add(async () => pTimeout2((async () => {
      await new Promise((resolve) => {
        res(() => {
          resolve();
        });
      });
    })(), {
      milliseconds: options.timeout
    }));
    return p;
  }
  var createMutex = (name, options) => {
    if (implementation.isWorker === true) {
      return {
        readLock: implementation.readLock(name, options),
        writeLock: implementation.writeLock(name, options)
      };
    }
    const masterQueue = new dist_default({ concurrency: 1 });
    let readQueue;
    return {
      async readLock() {
        if (readQueue != null) {
          return createReleaseable(readQueue, options);
        }
        readQueue = new dist_default({
          concurrency: options.concurrency,
          autoStart: false
        });
        const localReadQueue = readQueue;
        const readPromise = createReleaseable(readQueue, options);
        void masterQueue.add(async () => {
          localReadQueue.start();
          await localReadQueue.onIdle().then(() => {
            if (readQueue === localReadQueue) {
              readQueue = null;
            }
          });
        });
        return readPromise;
      },
      async writeLock() {
        readQueue = null;
        return createReleaseable(masterQueue, options);
      }
    };
  };
  var defaultOptions2 = {
    name: "lock",
    concurrency: Infinity,
    timeout: 846e5,
    singleProcess: false
  };
  function createMortice(options) {
    const opts = Object.assign({}, defaultOptions2, options);
    if (implementation == null) {
      implementation = browser_default(opts);
      if (implementation.isWorker !== true) {
        implementation.addEventListener("requestReadLock", (event) => {
          if (mutexes[event.data.name] == null) {
            return;
          }
          void mutexes[event.data.name].readLock().then(async (release) => event.data.handler().finally(() => {
            release();
          }));
        });
        implementation.addEventListener("requestWriteLock", async (event) => {
          if (mutexes[event.data.name] == null) {
            return;
          }
          void mutexes[event.data.name].writeLock().then(async (release) => event.data.handler().finally(() => {
            release();
          }));
        });
      }
    }
    if (mutexes[opts.name] == null) {
      mutexes[opts.name] = createMutex(opts.name, opts);
    }
    return mutexes[opts.name];
  }

  // node_modules/delay/index.js
  var createAbortError = () => {
    const error = new Error("Delay aborted");
    error.name = "AbortError";
    return error;
  };
  var clearMethods = /* @__PURE__ */ new WeakMap();
  function createDelay({ clearTimeout: defaultClear, setTimeout: defaultSet } = {}) {
    return (milliseconds, { value, signal } = {}) => {
      if (signal?.aborted) {
        return Promise.reject(createAbortError());
      }
      let timeoutId;
      let settle;
      let rejectFunction;
      const clear = defaultClear ?? clearTimeout;
      const signalListener = () => {
        clear(timeoutId);
        rejectFunction(createAbortError());
      };
      const cleanup = () => {
        if (signal) {
          signal.removeEventListener("abort", signalListener);
        }
      };
      const delayPromise = new Promise((resolve, reject) => {
        settle = () => {
          cleanup();
          resolve(value);
        };
        rejectFunction = reject;
        timeoutId = (defaultSet ?? setTimeout)(settle, milliseconds);
      });
      if (signal) {
        signal.addEventListener("abort", signalListener, { once: true });
      }
      clearMethods.set(delayPromise, () => {
        clear(timeoutId);
        timeoutId = null;
        settle();
      });
      return delayPromise;
    };
  }
  var delay = createDelay();
  var delay_default = delay;

  // test/fixtures/lock.ts
  async function lock(type, muxex, counts, result, timeout = 0) {
    counts[type]++;
    const index = counts[type];
    result.push(`${type} ${index} waiting`);
    const release = await muxex[`${type}Lock`]();
    result.push(`${type} ${index} start`);
    if (timeout > 0) {
      await delay_default(timeout);
    }
    result.push(`${type} ${index} complete`);
    release();
  }

  // test/fixtures/worker.ts
  async function run() {
    const mutex = createMortice();
    const counts = {
      read: 0,
      write: 0
    };
    const result = [];
    void lock("write", mutex, counts, result);
    void lock("read", mutex, counts, result);
    void lock("read", mutex, counts, result);
    void lock("read", mutex, counts, result, 500);
    void lock("write", mutex, counts, result);
    await lock("read", mutex, counts, result);
    return result;
  }
  run().then((result = []) => {
    globalThis.postMessage({
      type: "done",
      result
    });
  }, (err) => {
    globalThis.postMessage({
      type: "error",
      error: {
        message: err.message,
        stack: err.stack
      }
    });
  });
})();
